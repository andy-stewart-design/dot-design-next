---
title: Dynamic SVG Pie Charts
abstract: Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
published: "2023-07-11T12:00:00-0400"
---

# Dynamic SVG Pie Charts

Not all SVGs are created equal.

Or, to be more precise, not all SVG renderers are created equal. [SVG](https://www.w3.org/TR/SVG2/), like many of the technologies we use in our work, is a specification—a standardized set of principles, which were written out and agreed upon, and then interpretted and executed by a variety of parties over time. This process is ultimately a good faith agreement, meaning that any individual implementation may or may not be feature-complete and standard-compliant.

In a time with [such a large emphasis on parity](https://web.dev/blog/interop-2024), it’s a truth that can be easy to forget. That is, until it isn’t.

## The Problem

I built my first [Figma widget](https://www.figma.com/widget-docs/) recently. Simply put, widgets are Figma components with super powers. They live on your design or FigJam canvas like any other component, but are hydrated with Javascript and are therefore interactive. For our purposes, we built a simple checklist widget to help product designers prepare their files for production and increase transparency in design handoffs.

Given that widgets have to live amongst all your other, common components, Figma provides an understandably limited set of tools to buld them. In our widget, we wanted to include some sort of visual indicator of a user’s progress through the checklist. Given these limitations, the only path forward seemed to be SVG. My options were even more limited than I realized, however, which became apparent when I attempted to draw a donut chart using the `stroke-dasharray` and `stroke-dashoffset` properties, as [outlined in a great article](https://heyoka.medium.com/scratch-made-svg-donut-pie-charts-in-html5-2c587e935d72) by Mark Caron.

[Image of expectation v reality in Figma]

To my surpise, Figma's implementation of SVG is non-standard. The `stroke-dasharray` property does not render the same in Figma as it does in browsers, and so the most simple solution turned out to be a nonstarter.

But necessity is the mother of invention. My final solution ended up being more flexible than rendering the charts with strokes alone, and also demonstrates a few key concepts of designing and building with SVG (and math!):

1. Programatically drawing paths based on a dynamic set of inputs
2. Using clipping masks to define and shape our graphic's silhouette
3. Using `sin` and `cos` to visualize our current progress

Here's a preview of what we'll be building, which I'll break down step-by-step below.

<ProgressIndicator />

## Getting On the Grid

An SVG is a world unto itself. Especially in terms of layout, it cares little about what's happening outside of its four corners. SVGs are arranged along a two dimensional grid with their origin in the top left corner (much like a [2D HTML canvas](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)). The bounds of that grid are defined by an SVG's `viewBox`—a string of 4 space-separated numbers corresponding to the `x` and `y` coordinates of the top-left and bottom-right corners of the SVG, respectively. For all practical purposes, the first two numbers are always 0, and the last two numbers are often (but not necessarily) the same as the SVG's width and height. Importantly, though, no matter how large or small the SVG is displayed on screen, the viewBox—and coordinates of the grid that it defines—never changes.

```html
<svg viewBox="0 0 32 24"></svg>
```

The code above renders an SVG that spans from 0 to 32 units along the x-axis and from 0 to 24 units along the y-axis. Keep in mind, though, that although these units are established by the SVG’s `viewBox`, they scale linearly with its `width`. If you added a circle with a `stroke-width` of 2 to the above SVG but then rendered it at 96px wide (3x the `viewBox`), that stroke would look roughly equivalent to a 6px line outside of the SVG.

And speaking of circles—have you ever delved into the guts of an SVG file? If so, you may be aware that a small set of [basic shapes](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Basic_Shapes) exist: circles, rectangles, and polygons, for example, can all be easily constructed using native SVG elements. If your drawing uses only geometric shapes, these elements can make your job much simpler.

Before we move on to drawing more complex shapes, take a moment to play around with the sandbox below. Move the circle around, resize the SVG, and generally get a feel for how the allocation of space works inside of an SVG.

<SVGGrid />

## Drawing Dynamic Paths

We've talked about how to render simple geometric shapes. But what about when we need to draw something more complex, like the wedges of our pie chart? For that, we’ll need to forgo the convenience of these built-in elements in favor of a more flexible primitive: the SVG `path` element.

The thing that makes paths special and infinitely malleable is its `d` parameter, which allows you to define shapes using a small set of commands. These so-called **line commands** provide us with the tools to draw effectively any two dimensinal shape imaginable, one point at a time. Line commands encode two essential bits of information: where are we going next, and how should we get there.

These commands may look obtuse and intimidating at first, like some illegible robot hieroglyphics. Spend some time with them, though. You may be surprised how quickly you pick them up. For this project, we need to talk specifically about 4 of these commands:

1. **Move To**, represented by the letter `M`, which allows you to update the origin point of a shape without drawing a visible line. Unless your path is drawn starting at the origin point, it will begin with a MoveTo command.
2. **Line To**, represented by the letter `L`, which allows you to connect one point to another with a straight line.
3. **Arc To**, represented by the letter `A`, which allows you to connect one point to another with a portion of a circle or ellipse.
4. **Close Path**, represented by the letter `Z`, which can be added at the end of a path to connect the last point back to the first point in the path.

Because Arc To is by far the most complex command of this bunch, let's look more closely at the other three and then circle back on it (nyuk, nyuk, nyuk).

**Move To** and **Line To** commands are identical in their structure: they begin with their respective letter (`M` or `L`) followed by two numbers (the x- and y-coordinates of the next point in the path). The only difference between the two is that Line To commands connect the previously defined point to the next point with a visible line. So for example, the following code would draw a straight, 45° line starting at (2, 4) and then moving down 6 units down and to the right 6 units to (8, 10):

```
<path d="M 2 4 L 8 10" stroke="2" fill="none">
```

The **Close Path** command is even simpler—it’s literally just the letter `Z`. By calling this command, you're effectively telling the path "connect the previous point to my shape’s origin point with a straight line." In the previous example, if we added an additional Line To command followed by a Close Path command, we would draw a triangle.

Before we move on, check out the demo below. Click anywhere on the SVG to add a new point, or try moving existing points around, and watch the path update in real time.

<PathDrawing />

## Circling Back to Arcs

Now that we’ve got a feel for the simpler line command, it's time to turn it up a notch. The **Arc To** command consists of the letter `A` followed by 7 numbers. Let's break down the significance of these numbers down one-by-one:

1. The first two numbers describe the x- and y-radii of the rendered arc. These can be different if you need to draw an ellipse rather than a perfect circle. For our purposes, though, we only ever need to draw circles, so we can simplify things and always set them to the same value.
2. The third number describes the rotation of the ellipse. This only has an effect if your x- and y-radii are different, so we can safely set this to 0 and move on. (And honestly, I would most likely reach for the [bezier line command](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#b%C3%A9zier_curves) before I bothered trying to work with this.)
3. The fourth number, the `large-arc` flag, can be set to either `0` or `1` and determines whether the rendered line should trace the longer or shorter route around the circle. `0` draws the shorter arc while `1` draws the longer.
4. The fifth number, the `sweep` flag, is also a binary. This one is wonkier, but the way that I like to understand it is that this flag determines the direction (clockwise or counterclockwise) that the arc is drawn **relative to the position of the two points**. So, if your next point is directly below your previous point, `0` draws the arc in a counterclockwise direction while `1` draws it clockwise. That direction will rotate, however, as you move one point relative to the other.
5. And finally, the last two numbers simply define the x- and y- coordinates of the next point in the path—just like the previous commands we've discussed.

I’ve provided another sandbox below to help you get a handle on these concepts. But first, I’d like to share a few observations that I made while building this demo:

- If you toggle the `large arc` and `sweep direction` flags back and forth in tandem, you'll see two sections that, together, form a complete circle (or ellipse).
- The minimum diameter for an arc is equal to the distance between the two points (derived by the [Pythagorean Theorem](https://en.wikipedia.org/wiki/Pythagorean_theorem)). In other words, setting the diameter to a value less than that distance is effectively the same as setting it to that distance. That's why the radius input in the demo updates dynamically based on the position of the points.
- If the next point specified in the Arc To command is in the same position as the previous point, the arc will not be drawn. This makes sense, of course—you also can’t draw a straight line between these two points—but we’ll need to account for this quirk when drawing the wedges of our chart.

<ArcDrawing />

To recap, dyamically constructing paths with code really is as straightforward as knowing the points that you need to create a shape, and understanding enough about the various line commands to be able to connect one point to the next. It is, for sure, more abstract than creating SVGs with Figma or Illustrator, but it’s not conceptually all that different. Now, let’s talk about about one more concept we need to understand to be able to put this knowledge to work and generate our pie chart.

```Javascript
// ADD CODE HERE SHOWING HOW TO DRAW A PIE SHAPED PATH
```

## Sine and Cosine

Close your eyes and visualize a sound wave. You might, in your mind’s eye, see a smooth, geometric waveform oscillating endlessly in a regular up-and-down pattern. That, my friend, is a sine wave.

Now imagine a straight line shooting through the vertical center of that wave. Trace the wave as it oscillates up and down around that center line. Consider how you could stop at any point along the wave and calculate it’s distance from that center line—positive if it’s above, negative if it’s below, zero if it intersects with the line. These qualities are the primary source of value that sine waves bring to coding:

- they are **periodic**: they loop seamlessly and infinitely, starting and ending at the exact same point
- they are **harmonic**: they have a smooth, fluid rhythm due to the way that they ease into and out of their maximum and minimum points
- they are **symmetrical**: the distance from any point along the wave to the center line will be between a number and it’s inverse (n and -n)

Now, what if I told you that sine waves have these characteristics because they are derived from circles—that we can use the sine function to translate a percentage into a specific point along the perimeter of a circle?

<SineAnimation />

I want to avoid jargon in this conversation as much as possible. However, we do need to define a few key terms to help us make the jump from sine waves to pie charts:

- The **radius** of a circle is the distance from it’s center to it’s outer edge
- The **circumference** is the length of the perimeter of a circle, and is equal to it’s radius multiplied by two times pi (2πr). (Crucially, you don’t need to know anyting about pi beyond the fact that you need two of them to draw a full circle.)
- A **unit circle** is a circle with a radius of 1, meaning it’s circumference is simply equal to 2π.
- **Radians** are a unit of measurement that describe the angle formed by an arc relative to the radius of a circle. If you find that definition confusing—don’t worry. All you really need to know is that for a unit circle, the angle of an arc in radians will be some fraction of it’s circumfrence (2π).

At its most basic, a sine function calculates the distance from any point along a sine wave to the center line. Because sine functions generally operate on a unit circle, the distance calculated will always be between -1 and 1. To find this distance, the sine function needs to know the angle, in radians, of the point we want to calculate, which we can find by multiplying the circumference of the unit circle by some percentage. In practice, you might express that like this:

```Javascript
// for a number (progress) between 0 and 100
const progress = 35;
const radians = (progress / 100) * (Math.PI * 2)
const distance = Math.sin(radians)
// distance: 0.8090169943749475
```

A cosine function is conceptually the same as a sine function. The only salient difference is that the value returned by cosine is **phase shifted**, which is a fancy way of saying that cosine functions start their calculations at a different point along the wave. In practical terms, the sine of 0 is 0, where the cosine of 0 is 1. It's the same wave, it just starts earlier.

<SineCos />

kajenrknrk

<SineCircle />

## Masking and Donut Holes

At this point, you could, in theory, use the techniques we've already discussed to draw your donut chart—hole and all. But as much as I love a good a math problem, that would be unnecessarily complex. Instead, we're going to use a technique called **masking** to greatly simplify the process of defining our chart’s silhouette.

I like to think of masks as custom viewports that allow us to describe which parts of a shape (or group of shapes) should or should not be displayed. Do you remember how shapes that are placed outside of the bounds of an SVG’s `viewBox` are not rendered? Masks serve a similar function, but they can use any 2D shape to define the contours of our drawing—not just basic rectangles.

Now, there is technically one other tool in the SVG toolbox that we could use to achieve this effect. Like masks, **clipping paths** also allow us to show and hide parts of our drawing. However, masks have a special feature that make them uniquely well-suited to our needs in this instance.

With both masks and clipping paths, we can combine multiple, simple shapes together to create more complex and interesting silhouettes. But with masks, specifically, we can use color to describe how those shapes should be combined—a feature known as **alpha transparency**. Inside of a `mask`, black shapes are added to the composite mask whereas white shapes are subtracted from the mask. If you've ever used Figma’s [Boolean Operations](https://help.figma.com/hc/en-us/articles/360039957534-Boolean-operations) or Illustrator's [Pathfinder](https://helpx.adobe.com/illustrator/using/combining-objects.html#pathfinder_panel_overview), this concept should feel relatively familiar.

For this project, we can achieve our chart’s donut shape by using a mask consisting of a small white circle centered on top of a large black circle:

```Javascript
<defs>
  <mask id="donut">
    <circle cx="10" cy="10" r="18" fill="black" />
    <circle cx="10" cy="10" r="6" fill="white" />
  </mask>
</defs>
```

Before you explore the demo below, I want to address a few other nuances of SVG masking that you may notice:

- Masks must be wrapped in a `defs` element, which allows us to store anything that we need to reference in our SVG, but that we do not want to render directly. This is also where we would define other "invisible" elements like clipping paths and [gradients](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Gradients).
- Elements inside of a mask can be any color, not just black or white. When you set a mask element to another color, like medium gray, that element will be added to the mask with a transparency equal to the color's lightness—which is where the name "alpha transparency" comes from.
- Stacking order does matter, just like in Figma's boolean operations. If you want to knock one shape out of another, for example, that shape must be positioned on top of the other. Below, move the shapes around to see this effect in action.

<SVGMask />

## Footnotes

1. Before you get too excited—widgets are only interactive on your canvas and are not interactive in the context of a prototype. If you mind, like mine, immediately began racing with all of the cool interactions you could build with this API—sorry.
